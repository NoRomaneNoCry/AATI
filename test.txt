#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <vector>
#include <opencv/cv.h>
#include <opencv/highgui.h>

/**
 * Inverse une image "en place"
 */
void invert (IplImage* img)
{
  int x,y;
  uchar *p;
  assert (img->depth == IPL_DEPTH_8U && img->nChannels == 1);

  for (y = 0; y < img->height; ++y)
  {
    for (x = 0; x < img->width; ++x)
    {
      // récupération d'un pointeur sur le pixel de coordonnées (x,y)
      p = cvPtr2D (img, y, x, NULL);
      *p = 255 - *p;
    }
  }
}

void filtrePrewitt(std::vector<std::vector<int> > &f)
{
  f.resize(3);
  for (int i = 0; i != f.size(); ++i)
  {
    f[i].resize(3);

    f[i][0] = -1;
    f[i][1] = 0;
    f[i][2] = 1;
  }
}

void appliquefiltre(std::vector<std::vector<int> > &f, IplImage* img)
{
  
}

/**
 * Ce programme prend deux arguments dont un optionnel:
 * IMAGE:     l'image à inverser
 * SAVE_PATH: (optionnel) l'image dans laquelle sauvegarder le résultat
 */
int main (int argc, char* argv[])
{
  IplImage* img = NULL; 
  const char* src_path = NULL;
  const char* dst_path = NULL;
  const char* window_title = "Inverse";

  std::vector<std::vector<int> > filtre;

  filtrePrewitt(filtre);
  if (argc < 2)
  {
    fprintf (stderr, "usage: %s IMAGE [SAVE_PATH]\n", argv[0]);
    return EXIT_FAILURE;
  }

  src_path = argv[1];

   // optionnel: sauvegarde du résultat 
   // si un second chemin est passé au programme
  if (argc > 2) 
    dst_path = argv[2];

  if (!(img = cvLoadImage (src_path, CV_LOAD_IMAGE_GRAYSCALE)))
  {
    fprintf (stderr, "couldn't open image file: %s\n", argv[1]);
    return EXIT_FAILURE;
  }

  invert (img);

  cvNamedWindow (window_title, CV_WINDOW_AUTOSIZE);
  cvShowImage   (window_title, img);
  cvWaitKey (0);
  cvDestroyAllWindows ();
  
  if (dst_path && !cvSaveImage (dst_path, img, NULL))
  {
    fprintf (stderr, "couldn't write image to file: %s\n", dst_path);
  }
  
  cvReleaseImage(&img);
  return EXIT_SUCCESS;
}
